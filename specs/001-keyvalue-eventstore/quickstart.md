# Quickstart: KeyValue Event Store

**Feature**: 001-keyvalue-eventstore
**Date**: 2026-01-03

## Overview

This guide demonstrates how to use the Hexalith.EventStores library to implement event sourcing in your .NET applications.

---

## Installation

```bash
# Add the NuGet packages
dotnet add package Hexalith.EventStores
dotnet add package Hexalith.KeyValueStorages.Files  # or another storage backend
```

---

## Basic Usage

### 1. Define Your Domain Events

Create events as polymorphic records with the `[PolymorphicSerialization]` attribute:

```csharp
using Hexalith.PolymorphicSerializations;

[PolymorphicSerialization]
public partial record BankAccountCreated(
    string AccountId,
    string OwnerName,
    string Currency);

[PolymorphicSerialization]
public partial record FundsDeposited(
    string AccountId,
    decimal Amount,
    DateTimeOffset Timestamp);

[PolymorphicSerialization]
public partial record FundsWithdrawn(
    string AccountId,
    decimal Amount,
    DateTimeOffset Timestamp);
```

### 2. Register Polymorphic Mappers

In your application startup, register the generated mappers:

```csharp
// Generated by source generator based on [PolymorphicSerialization] attributes
YourAssemblySerialization.RegisterPolymorphicMappers();
```

### 3. Create the Event Store Provider

```csharp
using Hexalith.EventStores;
using Hexalith.KeyValueStorages.Files;
using Hexalith.PolymorphicSerializations;

// Create a key-value storage provider (file-based in this example)
var keyValueProvider = new JsonFileKeyValueProvider(
    options: PolymorphicHelper.DefaultJsonSerializerOptions);

// Create the event store provider
var provider = new KeyValueEventStoreProvider(keyValueProvider);
```

### 4. Open an Event Store and Add Events

```csharp
// Open a store for a specific aggregate
IEventStore store = await provider.OpenStoreAsync(
    "BankAccount",    // Aggregate type
    "123456000",      // Aggregate ID
    CancellationToken.None);

try
{
    // Add multiple events at once
    await store.AddAsync(
    [
        new BankAccountCreated("123456000", "Joe Dalton", "EUR").CreateMessage(),
        new FundsDeposited("123456000", 1500m, DateTimeOffset.Now).CreateMessage(),
    ],
    CancellationToken.None);

    // Add more events
    await store.AddAsync(
        [new FundsWithdrawn("123456000", 500m, DateTimeOffset.Now).CreateMessage()],
        CancellationToken.None);
}
finally
{
    store.Close();
}
```

### 5. Retrieve Events

```csharp
// Get all events
IEnumerable<EventMessage> history = await store.GetAsync(CancellationToken.None);

foreach (var message in history)
{
    Console.WriteLine($"Event: {message.Event.GetType().Name}");
    Console.WriteLine($"  Version: {message.Metadata.Context.SequenceNumber}");
}
```

---

## Using async/await with Dispose

For cleaner resource management, use `await using`:

```csharp
await using IEventStore store = await provider.OpenStoreAsync("Order", orderId, ct);

await store.AddAsync(events, ct);
var history = await store.GetAsync(ct);

// Store automatically closed and disposed when leaving scope
```

---

## Optimistic Concurrency

Use sequence numbers to detect concurrent modifications:

```csharp
// Get current version
long currentVersion = await store.VersionAsync(ct);

// Create event with expected sequence number
var withdrawal = new FundsWithdrawn(accountId, 500m, DateTimeOffset.Now)
    .CreateMessage(sequenceNumber: currentVersion + 1);

try
{
    await store.AddAsync([withdrawal], ct);
}
catch (StoreVersionMismatchException ex)
{
    Console.WriteLine($"Conflict: expected version {ex.ExpectedVersion}, actual {ex.ActualVersion}");
    // Reload and retry with updated version
}
```

---

## Working with Snapshots

For aggregates with long event histories, use snapshots to optimize loading:

### Create a Snapshot

```csharp
// Replay events to compute current state
var events = await store.GetAsync(useSnapshot: false, ct);
var state = ReplayEvents(events);

// Save snapshot at current version
long version = await store.VersionAsync(ct);
var snapshotMessage = new BankAccountState(state).CreateMessage();
await store.SnapshotAsync(version, snapshotMessage, ct);
```

### Load with Snapshot

```csharp
// Automatically uses most recent snapshot
var events = await store.GetAsync(useSnapshot: true, ct);

// First event will be the snapshot, followed by events since snapshot
foreach (var message in events)
{
    if (message.Event is BankAccountState snapshot)
    {
        // Initialize from snapshot
        state = snapshot;
    }
    else
    {
        // Apply subsequent events
        state = Apply(state, message.Event);
    }
}
```

### Auto-Generate Snapshots

```csharp
// Create snapshots every 100 events
await store.SnapshotAllAsync(
    chunkSize: 100,
    snapshot: events => ComputeState(events).CreateMessage(),
    ct);
```

---

## Event Slicing

Retrieve a specific range of events:

```csharp
// Get events 50-75
var slice = await store.GetSliceAsync(first: 50, last: 75, ct);

// Get events from version 100 onwards
long current = await store.VersionAsync(ct);
var recentEvents = await store.GetSliceAsync(100, current, ct);
```

---

## Dependency Injection Setup

### Registration

```csharp
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddEventStore(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // Configure settings
        services.Configure<EventStoreSettings>(
            configuration.GetSection("Hexalith:EventStores"));

        // Register key-value storage (choose your backend)
        services.AddSingleton<IKeyValueProvider, JsonFileKeyValueProvider>();

        // Register event store provider
        services.AddSingleton<IEventStoreProvider, KeyValueEventStoreProvider>();

        return services;
    }
}
```

### Configuration (appsettings.json)

```json
{
  "Hexalith": {
    "EventStores": {
      "DefaultDatabase": "EventStores",
      "DefaultOpenTimeout": "00:00:05",
      "DefaultSessionTimeout": "00:01:00"
    }
  }
}
```

### Usage in Services

```csharp
public class OrderService(IEventStoreProvider storeProvider)
{
    public async Task<Order> PlaceOrderAsync(PlaceOrderCommand command, CancellationToken ct)
    {
        await using var store = await storeProvider.OpenStoreAsync(
            "Order", command.OrderId, ct);

        var orderPlaced = new OrderPlaced(command.OrderId, command.Items);
        await store.AddAsync([orderPlaced.CreateMessage()], ct);

        return new Order(command.OrderId, command.Items);
    }

    public async Task<Order> GetOrderAsync(string orderId, CancellationToken ct)
    {
        await using var store = await storeProvider.OpenStoreAsync("Order", orderId, ct);

        var events = await store.GetAsync(ct);
        return Order.Replay(events.Select(e => e.Event));
    }
}
```

---

## Multi-Tenant Scenarios

Use the database parameter for tenant isolation:

```csharp
await using var store = await provider.OpenStoreAsync(
    database: tenantId,     // Partition by tenant
    name: "Order",
    id: orderId,
    ct);
```

---

## Error Handling

```csharp
try
{
    await using var store = await provider.OpenStoreAsync("Order", orderId, ct);
    await store.AddAsync(events, ct);
}
catch (OpenStoreFailedException ex)
{
    logger.LogError("Could not acquire lock for {StoreId} within {Timeout}",
        ex.StoreId, ex.Timeout);
    throw;
}
catch (StoreVersionMismatchException ex)
{
    logger.LogWarning("Optimistic concurrency conflict: expected {Expected}, was {Actual}",
        ex.ExpectedVersion, ex.ActualVersion);
    // Reload and retry
}
catch (StoreSessionExpiredException ex)
{
    logger.LogWarning("Session {Session} expired at {Expiration}",
        ex.SessionId, ex.Expiration);
    // Reopen store and retry
}
```

---

## Storage Backends

The event store works with any Hexalith.KeyValueStorages implementation:

| Backend | Package | Use Case |
|---------|---------|----------|
| File-based JSON | `Hexalith.KeyValueStorages.Files` | Development, testing |
| In-memory | `Hexalith.KeyValueStorages` | Unit tests |
| Dapr State Store | `Hexalith.KeyValueStorages.DaprComponents` | Production with Dapr |

---

## Next Steps

- See the full [Bank Account Example](../src/examples/Hexalith.EventStores.Example/)
- Read the [API Contracts](./contracts/) for detailed interface documentation
- Review the [Data Model](./data-model.md) for entity details
